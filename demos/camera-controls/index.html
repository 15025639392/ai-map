<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›¸æœºæ§åˆ¶ - WebGL2 æ¸²æŸ“å¼•æ“</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 20px;
            max-width: 1000px;
            width: 100%;
        }

        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            display: block;
            margin: 0 auto 20px;
            cursor: move;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: #667eea;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
        }

        .info-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .info-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
        }

        .controls-info {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin-top: 15px;
            font-size: 13px;
            color: #856404;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <h1>ğŸ¨ ç›¸æœºæ§åˆ¶ - WebGL2 æ¸²æŸ“å¼•æ“</h1>
    <div id="container">
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="controls">
            <button onclick="resetCamera()">é‡ç½®ç›¸æœº</button>
            <button onclick="topView()">é¡¶è§†å›¾</button>
            <button onclick="frontView()">å‰è§†å›¾</button>
            <button onclick="sideView()">ä¾§è§†å›¾</button>
            <button onclick="toggleAutoRotate()">åˆ‡æ¢è‡ªåŠ¨æ—‹è½¬</button>
        </div>

        <div class="info">
            <div class="info-item">
                <div class="info-label">ä½ç½® X</div>
                <div class="info-value" id="cameraX">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">ä½ç½® Y</div>
                <div class="info-value" id="cameraY">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">ä½ç½® Z</div>
                <div class="info-value" id="cameraZ">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">æ—‹è½¬ Y</div>
                <div class="info-value" id="rotation">0Â°</div>
            </div>
            <div class="info-item">
                <div class="info-label">ç¼©æ”¾</div>
                <div class="info-value" id="zoom">1.0x</div>
            </div>
            <div class="info-item">
                <div class="info-label">è‡ªåŠ¨æ—‹è½¬</div>
                <div class="info-value" id="autoRotate">å…³é—­</div>
            </div>
        </div>

        <div class="controls-info">
            <strong>æ§åˆ¶æ–¹å¼ï¼š</strong>
            <ul>
                <li>é¼ æ ‡æ‹–æ‹½ï¼šæ—‹è½¬ç›¸æœº</li>
                <li>é¼ æ ‡æ»šè½®ï¼šç¼©æ”¾è§†å›¾</li>
                <li>å³é”®æ‹–æ‹½ï¼šå¹³ç§»è§†å›¾</li>
                <li>é”®ç›˜ W/A/S/Dï¼šç§»åŠ¨ç›¸æœº</li>
                <li>é”®ç›˜ +/-ï¼šç¼©æ”¾</li>
            </ul>
        </div>
    </div>

    <script type="module">
        // WebGL ä¸Šä¸‹æ–‡
        let gl = null;
        let program = null;

        // ç›¸æœºçŠ¶æ€
        const camera = {
            x: 0,
            y: 5,
            z: 10,
            rotationY: 0,
            rotationX: 0,
            zoom: 1.0,
            autoRotate: false
        };

        // äº¤äº’çŠ¶æ€
        let isDragging = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // åˆå§‹åŒ– WebGL
        function initWebGL() {
            const canvas = document.getElementById('canvas');
            gl = canvas.getContext('webgl2');
            
            if (!gl) {
                alert('WebGL2 ä¸è¢«æ”¯æŒï¼Œè¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨');
                return false;
            }

            // è®¾ç½®è§†å£
            gl.viewport(0, 0, canvas.width, canvas.height);

            // å¯ç”¨æ·±åº¦æµ‹è¯•
            gl.enable(gl.DEPTH_TEST);

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('resize', onResize);

            // åˆ›å»ºç€è‰²å™¨ç¨‹åº
            createShaders();

            // å¯åŠ¨æ¸²æŸ“å¾ªç¯
            requestAnimationFrame(render);

            console.log('âœ… ç›¸æœºæ§åˆ¶ç¤ºä¾‹å¯åŠ¨æˆåŠŸï¼');
            return true;
        }

        // åˆ›å»ºç€è‰²å™¨
        function createShaders() {
            // é¡¶ç‚¹ç€è‰²å™¨
            const vertexShaderSource = `
                attribute vec4 a_position;
                attribute vec4 a_color;
                
                uniform mat4 u_modelView;
                uniform mat4 u_projection;
                
                varying vec4 v_color;
                
                void main() {
                    gl_Position = u_projection * u_modelView * a_position;
                    v_color = a_color;
                }
            `;

            // ç‰‡æ®µç€è‰²å™¨
            const fragmentShaderSource = `
                precision mediump float;
                varying vec4 v_color;
                
                void main() {
                    gl_FragColor = v_color;
                }
            `;

            // åˆ›å»ºç€è‰²å™¨
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            // åˆ›å»ºç¨‹åº
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ç€è‰²å™¨ç¨‹åºé“¾æ¥å¤±è´¥:', gl.getProgramInfoLog(program));
                return;
            }
        }

        // åˆ›å»ºç€è‰²å™¨
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('ç€è‰²å™¨ç¼–è¯‘å¤±è´¥:', gl.getShaderInfoLog(shader));
                return null;
            }
            
            return shader;
        }

        // åˆ›å»ºåœºæ™¯å‡ ä½•ä½“ï¼ˆç«‹æ–¹ä½“ï¼‰
        function createCube() {
            const vertices = new Float32Array([
                // å‰é¢
                -1, -1,  1,   1, 0.2, 0.2,
                 1, -1,  1,   1, 0.2, 0.2,
                 1,  1,  1,   1, 0.2, 0.2,
                -1,  1,  1,   1, 0.2, 0.2,
                
                // åé¢
                -1, -1, -1,   0.2, 1, 0.2,
                 1, -1, -1,   0.2, 1, 0.2,
                 1,  1, -1,   0.2, 1, 0.2,
                -1,  1, -1,   0.2, 1, 0.2,
                
                // ä¸Šé¢
                -1,  1, -1,   0.2, 0.2, 1,
                 1,  1, -1,   0.2, 0.2, 1,
                 1,  1,  1,   0.2, 0.2, 1,
                -1,  1,  1,   0.2, 0.2, 1,
                
                // ä¸‹é¢
                -1, -1, -1,   1, 1, 0.2,
                 1, -1, -1,   1, 1, 0.2,
                 1, -1,  1,   1, 1, 0.2,
                -1, -1,  1,   1, 1, 0.2,
                
                // å³é¢
                 1, -1, -1,   1, 0.2, 1,
                 1, -1,  1,   1, 0.2, 1,
                 1,  1,  1,   1, 0.2, 1,
                 1,  1, -1,   1, 0.2, 1,
                
                // å·¦é¢
                -1, -1, -1,   0.2, 1, 1,
                -1, -1,  1,   0.2, 1, 1,
                -1,  1,  1,   0.2, 1, 1,
                -1,  1, -1,   0.2, 1, 1,
            ]);

            const indices = new Uint16Array([
                0, 1, 2, 0, 2, 3,
                4, 5, 6, 4, 6, 7,
                8, 9, 10, 8, 10, 11,
                12, 13, 14, 12, 14, 15,
                16, 17, 18, 16, 18, 19,
                20, 21, 22, 20, 22, 23
            ]);

            return { vertices, indices };
        }

        // çŸ©é˜µå·¥å…·å‡½æ•°
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ]);
        }

        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }

        function rotateY(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new Float32Array([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }

        function translate(x, y, z) {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ]);
        }

        function scale(s) {
            return new Float32Array([
                s, 0, 0, 0,
                0, s, 0, 0,
                0, 0, s, 0,
                0, 0, 0, 1
            ]);
        }

        // æ¸²æŸ“å‡½æ•°
        function render() {
            if (!gl || !program) return;

            // æ¸…ç©ºç”»å¸ƒ
            gl.clearColor(0.1, 0.1, 0.15, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // ä½¿ç”¨ç¨‹åº
            gl.useProgram(program);

            // åˆ›å»ºç«‹æ–¹ä½“
            const cube = createCube();

            // è®¾ç½®é¡¶ç‚¹æ•°æ®
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, cube.vertices, gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube.indices, gl.STATIC_DRAW);

            // è®¾ç½®å±æ€§
            const positionLoc = gl.getAttribLocation(program, 'a_position');
            const colorLoc = gl.getAttribLocation(program, 'a_color');

            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 24, 0);

            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 24, 12);

            // è®¡ç®—å˜æ¢çŸ©é˜µ
            const aspect = gl.canvas.width / gl.canvas.height;
            const projection = perspective(Math.PI / 4, aspect, 0.1, 100);
            
            // ç›¸æœºæ—‹è½¬ï¼ˆè‡ªåŠ¨æˆ–æ‰‹åŠ¨ï¼‰
            if (camera.autoRotate) {
                camera.rotationY += 0.01;
            }

            // æ¨¡å‹è§†å›¾çŸ©é˜µ
            let modelView = translate(0, 0, -camera.z * camera.zoom);
            modelView = multiply(modelView, rotateY(camera.rotationY));
            modelView = multiply(modelView, translate(camera.x, camera.y, 0));
            modelView = multiply(modelView, scale(camera.zoom));

            // è®¾ç½® uniform
            const projectionLoc = gl.getUniformLocation(program, 'u_projection');
            const modelViewLoc = gl.getUniformLocation(program, 'u_modelView');

            gl.uniformMatrix4fv(projectionLoc, false, projection);
            gl.uniformMatrix4fv(modelViewLoc, false, modelView);

            // ç»˜åˆ¶
            gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_SHORT, 0);

            // æ¸…ç†
            gl.deleteBuffer(vertexBuffer);
            gl.deleteBuffer(indexBuffer);

            // æ›´æ–° UI
            updateUI();

            requestAnimationFrame(render);
        }

        // æ›´æ–° UI
        function updateUI() {
            document.getElementById('cameraX').textContent = camera.x.toFixed(2);
            document.getElementById('cameraY').textContent = camera.y.toFixed(2);
            document.getElementById('cameraZ').textContent = camera.z.toFixed(2);
            document.getElementById('rotation').textContent = (camera.rotationY * 180 / Math.PI).toFixed(1) + 'Â°';
            document.getElementById('zoom').textContent = camera.zoom.toFixed(2) + 'x';
            document.getElementById('autoRotate').textContent = camera.autoRotate ? 'å¼€å¯' : 'å…³é—­';
        }

        // é¼ æ ‡äº‹ä»¶
        function onMouseDown(e) {
            if (e.button === 0) {
                isDragging = true;
            } else if (e.button === 2) {
                isPanning = true;
            }
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                camera.rotationY += deltaX * 0.01;
                camera.rotationX += deltaY * 0.01;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            } else if (isPanning) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                camera.x += deltaX * 0.01;
                camera.y -= deltaY * 0.01;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        }

        function onMouseUp() {
            isDragging = false;
            isPanning = false;
        }

        function onWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom *= delta;
            camera.zoom = Math.max(0.1, Math.min(5, camera.zoom));
        }

        function onKeyDown(e) {
            const speed = 0.1;
            switch(e.key.toLowerCase()) {
                case 'w':
                    camera.z -= speed;
                    break;
                case 's':
                    camera.z += speed;
                    break;
                case 'a':
                    camera.x -= speed;
                    break;
                case 'd':
                    camera.x += speed;
                    break;
                case '+':
                case '=':
                    camera.zoom *= 1.1;
                    break;
                case '-':
                case '_':
                    camera.zoom *= 0.9;
                    break;
            }
            camera.z = Math.max(1, camera.z);
        }

        function onResize() {
            const canvas = document.getElementById('canvas');
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        // æŒ‰é’®åŠŸèƒ½
        window.resetCamera = function() {
            camera.x = 0;
            camera.y = 0;
            camera.z = 10;
            camera.rotationY = 0;
            camera.rotationX = 0;
            camera.zoom = 1.0;
            camera.autoRotate = false;
        };

        window.topView = function() {
            camera.x = 0;
            camera.y = 10;
            camera.z = 1;
            camera.rotationY = 0;
        };

        window.frontView = function() {
            camera.x = 0;
            camera.y = 0;
            camera.z = 10;
            camera.rotationY = 0;
        };

        window.sideView = function() {
            camera.x = 10;
            camera.y = 0;
            camera.z = 0;
            camera.rotationY = Math.PI / 2;
        };

        window.toggleAutoRotate = function() {
            camera.autoRotate = !camera.autoRotate;
        };

        // åˆå§‹åŒ–
        initWebGL();
    </script>
</body>
</html>
