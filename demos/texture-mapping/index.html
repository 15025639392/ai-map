<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çº¹ç†æ˜ å°„ - WebGL2 æ¸²æŸ“å¼•æ“</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 20px;
            max-width: 1000px;
            width: 100%;
        }

        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            display: block;
            margin: 0 auto 20px;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: #30cfd0;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(48, 207, 208, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .info-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .info-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 16px;
            font-weight: bold;
            color: #30cfd0;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <h1>ğŸ¨ çº¹ç†æ˜ å°„ - WebGL2 æ¸²æŸ“å¼•æ“</h1>
    <div id="container">
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="controls">
            <button onclick="createCheckerTexture()">æ£‹ç›˜çº¹ç†</button>
            <button onclick="createGradientTexture()">æ¸å˜çº¹ç†</button>
            <button onclick="createNoiseTexture()">å™ªç‚¹çº¹ç†</button>
            <button onclick="toggleWrap()">åˆ‡æ¢åŒ…è£…æ¨¡å¼</button>
            <button onclick="toggleFilter()">åˆ‡æ¢æ»¤é•œ</button>
            <button onclick="resetView()">é‡ç½®è§†å›¾</button>
        </div>

        <div class="info">
            <div class="info-item">
                <div class="info-label">çº¹ç†ç±»å‹</div>
                <div class="info-value" id="textureType">æ£‹ç›˜</div>
            </div>
            <div class="info-item">
                <div class="info-label">çº¹ç†å°ºå¯¸</div>
                <div class="info-value">256x256</div>
            </div>
            <div class="info-item">
                <div class="info-label">åŒ…è£…æ¨¡å¼</div>
                <div class="info-value" id="wrapMode">é‡å¤</div>
            </div>
            <div class="info-item">
                <div class="info-label">æ»¤é•œ</div>
                <div class="info-value" id="filterMode">çº¿æ€§</div>
            </div>
            <div class="info-item">
                <div class="info-label">é¼ æ ‡ä½ç½®</div>
                <div class="info-value" id="mousePos">0, 0</div>
            </div>
        </div>
    </div>

    <script type="module">
        // WebGL ä¸Šä¸‹æ–‡
        let gl = null;
        let texture = null;
        let textureType = 'checker';

        // çŠ¶æ€
        let wrapMode = 'repeat';
        let filterMode = 'linear';
        let mouseX = 0;
        let mouseY = 0;

        // åˆå§‹åŒ– WebGL
        function initWebGL() {
            const canvas = document.getElementById('canvas');
            gl = canvas.getContext('webgl2');
            
            if (!gl) {
                alert('WebGL2 ä¸è¢«æ”¯æŒï¼Œè¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨');
                return false;
            }

            // è®¾ç½®è§†å£
            gl.viewport(0, 0, canvas.width, canvas.height);

            // åˆ›å»ºåˆå§‹çº¹ç†
            createCheckerTexture();

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseleave', onMouseLeave);
            window.addEventListener('resize', onResize);

            // å¯åŠ¨æ¸²æŸ“å¾ªç¯
            requestAnimationFrame(render);

            console.log('âœ… çº¹ç†æ˜ å°„ç¤ºä¾‹å¯åŠ¨æˆåŠŸï¼');
            return true;
        }

        // åˆ›å»ºæ£‹ç›˜çº¹ç†
        function createCheckerTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    const checker = ((x >> 4) + (y >> 4)) & 1;
                    const color = checker ? 
                        [255, 255, 255, 255] : // ç™½è‰²
                        [50, 50, 50, 255];      // ç°è‰²
                    data[i] = color[0];
                    data[i + 1] = color[1];
                    data[i + 2] = color[2];
                    data[i + 3] = color[3];
                }
            }

            createTextureFromData(data, size, size, 'checker');
            textureType = 'checker';
            updateUI();
        }

        // åˆ›å»ºæ¸å˜çº¹ç†
        function createGradientTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let y = 0; y < size; y++) {
                const t = y / size;
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    const s = x / size;
                    
                    // åˆ›å»º RGB æ¸å˜
                    data[i] = Math.floor(255 * (1.0 - t));
                    data[i + 1] = Math.floor(255 * s);
                    data[i + 2] = Math.floor(255 * t * s);
                    data[i + 3] = 255;
                }
            }

            createTextureFromData(data, size, size, 'gradient');
            textureType = 'gradient';
            updateUI();
        }

        // åˆ›å»ºå™ªç‚¹çº¹ç†
        function createNoiseTexture() {
            const size = 256;
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size * size * 4; i += 4) {
                data[i] = Math.floor(Math.random() * 255);
                data[i + 1] = Math.floor(Math.random() * 255);
                data[i + 2] = Math.floor(Math.random() * 255);
                data[i + 3] = 255;
            }

            createTextureFromData(data, size, size, 'noise');
            textureType = 'noise';
            updateUI();
        }

        // ä»æ•°æ®åˆ›å»ºçº¹ç†
        function createTextureFromData(data, width, height, type) {
            if (texture) {
                gl.deleteTexture(texture);
            }

            texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // ä¸Šä¼ çº¹ç†æ•°æ®
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                width,
                height,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                data
            );

            // è®¾ç½®åŒ…è£…æ¨¡å¼
            const wrap = wrapMode === 'repeat' ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);

            // è®¾ç½®æ»¤é•œ
            const filter = filterMode === 'linear' ? gl.LINEAR : gl.NEAREST;
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);

            // ç”Ÿæˆ mipmap
            gl.generateMipmap(gl.TEXTURE_2D);

            console.log(`âœ“ åˆ›å»ºçº¹ç†: ${type}`);
        }

        // æ¸²æŸ“å‡½æ•°
        function render() {
            if (!gl) return;

            // æ¸…ç©ºç”»å¸ƒ
            gl.clearColor(0.2, 0.3, 0.4, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            if (!texture) return;

            // é¡¶ç‚¹ç€è‰²å™¨
            const vertexShaderSource = `
                attribute vec4 a_position;
                attribute vec2 a_texCoord;
                
                uniform vec2 u_offset;
                uniform float u_scale;
                uniform float u_rotation;
                
                varying vec2 v_texCoord;
                
                void main() {
                    // åº”ç”¨æ—‹è½¬
                    float c = cos(u_rotation);
                    float s = sin(u_rotation);
                    mat2 rotation = mat2(c, -s, s, c);
                    
                    // åº”ç”¨ç¼©æ”¾
                    vec2 pos = a_position.xy * u_scale;
                    
                    // åº”ç”¨æ—‹è½¬
                    pos = rotation * pos;
                    
                    // åº”ç”¨åç§»
                    pos += u_offset;
                    
                    gl_Position = vec4(pos, a_position.z, a_position.w);
                    v_texCoord = a_texCoord;
                }
            `;

            // ç‰‡æ®µç€è‰²å™¨
            const fragmentShaderSource = `
                precision mediump float;
                
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                
                void main() {
                    vec4 color = texture2D(u_texture, v_texCoord);
                    gl_FragColor = color;
                }
            `;

            // åˆ›å»ºç€è‰²å™¨
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            // åˆ›å»ºç¨‹åº
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ç€è‰²å™¨ç¨‹åºé“¾æ¥å¤±è´¥:', gl.getProgramInfoLog(program));
                return;
            }

            // ä½¿ç”¨ç¨‹åº
            gl.useProgram(program);

            // è®¾ç½®é¡¶ç‚¹æ•°æ®ï¼ˆå¸¦çº¹ç†åæ ‡ï¼‰
            const vertices = new Float32Array([
                // ä½ç½®             // çº¹ç†åæ ‡
                -1.0, -1.0, 0.0,   0.0,
                 1.0, -1.0, 0.0,   1.0,
                -1.0,  1.0, 0.0,   0.0,
                 1.0,  1.0, 0.0,   1.0,
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            // è®¾ç½®å±æ€§
            const positionLoc = gl.getAttribLocation(program, 'a_position');
            const texCoordLoc = gl.getAttribLocation(program, 'a_texCoord');

            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 32, 0);

            gl.enableVertexAttribArray(texCoordLoc);
            gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 32, 8);

            // è®¾ç½® uniformï¼ˆé¼ æ ‡ä½ç½®æ§åˆ¶åç§»ï¼‰
            const offsetLoc = gl.getUniformLocation(program, 'u_offset');
            const scaleLoc = gl.getUniformLocation(program, 'u_scale');
            const rotationLoc = gl.getUniformLocation(program, 'u_rotation');
            const textureLoc = gl.getUniformLocation(program, 'u_texture');

            // åŸºäºé¼ æ ‡ä½ç½®è®¡ç®—åç§»
            const canvas = gl.canvas;
            const normalizedX = mouseX / canvas.width * 2 - 1;
            const normalizedY = -mouseY / canvas.height * 2 + 1;
            
            gl.uniform2f(offsetLoc, normalizedX * 0.3, normalizedY * 0.3);
            gl.uniform1f(scaleLoc, 1.0);
            gl.uniform1f(rotationLoc, 0.0);
            
            // ç»‘å®šçº¹ç†
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(textureLoc, 0);

            // ç»˜åˆ¶
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // æ¸…ç†
            gl.deleteBuffer(buffer);
            gl.deleteProgram(program);
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);

            requestAnimationFrame(render);
        }

        // åˆ›å»ºç€è‰²å™¨
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('ç€è‰²å™¨ç¼–è¯‘å¤±è´¥:', gl.getShaderInfoLog(shader));
                return null;
            }
            
            return shader;
        }

        // åˆ‡æ¢åŒ…è£…æ¨¡å¼
        window.toggleWrap = function() {
            wrapMode = wrapMode === 'repeat' ? 'clamp' : 'repeat';
            updateTextureParams();
            updateUI();
        };

        // åˆ‡æ¢æ»¤é•œ
        window.toggleFilter = function() {
            filterMode = filterMode === 'linear' ? 'nearest' : 'linear';
            updateTextureParams();
            updateUI();
        };

        // æ›´æ–°çº¹ç†å‚æ•°
        function updateTextureParams() {
            if (!texture) return;

            const wrap = wrapMode === 'repeat' ? gl.REPEAT : gl.CLAMP_TO_EDGE;
            const filter = filterMode === 'linear' ? gl.LINEAR : gl.NEAREST;

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        }

        // é‡ç½®è§†å›¾
        window.resetView = function() {
            mouseX = 400;
            mouseY = 300;
            updateUI();
        };

        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        function onMouseMove(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            updateUI();
        }

        function onMouseLeave() {
            // é¼ æ ‡ç¦»å¼€æ—¶ä¸æ›´æ–°
        }

        // çª—å£å¤§å°æ”¹å˜
        function onResize() {
            const canvas = document.getElementById('canvas');
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        // æ›´æ–° UI
        function updateUI() {
            document.getElementById('textureType').textContent = {
                'checker': 'æ£‹ç›˜',
                'gradient': 'æ¸å˜',
                'noise': 'å™ªç‚¹'
            }[textureType];

            document.getElementById('wrapMode').textContent = {
                'repeat': 'é‡å¤',
                'clamp': 'é’³ä½'
            }[wrapMode];

            document.getElementById('filterMode').textContent = {
                'linear': 'çº¿æ€§',
                'nearest': 'æœ€è¿‘'
            }[filterMode];

            document.getElementById('mousePos').textContent = `${Math.floor(mouseX)}, ${Math.floor(mouseY)}`;
        }

        // åˆå§‹åŒ–
        initWebGL();
    </script>
</body>
</html>
